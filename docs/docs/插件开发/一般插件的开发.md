# 一般插件的开发

## 总体框架

```python
from nonebot import on_message, on_notice, on_request, on_metaevent
from nonebot.adapters.onebot.v11 import MessageEvent
from nonebot.rule import Rule
from nonebot.permission import Permission


matcher = on_message(
    rule=Rule(

    ),
    permission=Permission(
    
    ),
    priority=0,
    block=False
)


@matcher.handle()
async def handle_message(event: MessageEvent):
    print(event.message)

```

## 事件响应器

[Nonebot官方文档 - 事件响应器](https://nonebot.dev/docs/tutorial/matcher)

nonebot提供了各种各样的响应器，详见[进阶事件响应器](https://nonebot.dev/docs/advanced/matcher)

这里只推荐采用四个大类，分别是`on_metaevent`, `on_message`, `on_request`以及`on_notice`，四种事件响应器分别对应了元事件、消息事件、请求事件以及通知事件

### 时间响应器类的构建

他们都含有几个常用参数: `rule`, `permission`, `priority`, `block`等

#### rule

[Nonebot官方文档 - 响应规则](https://nonebot.dev/docs/appendices/rule)

`rule`这个参数前有`Rule`与`RuleChecker`两个概念

`RuleChecker`是一个返回值为`bool`的函数

```python
from nonebot.rule import Rule

async def func() -> bool:
  ...
```

这样的一个函数就被称为`RuleChecker`

`Rule`是若干个`RuleChecker`的集合，当所有`RuleChecker`都返回`True`的时候，才会通过整个`Rule`

```python
from nonebot.rule import Rule
from nonebot.adapters.onebot.v11 import Event

async def rule_checker1(event: Event) -> bool:
  ...
  
async def rule_checker2(event: Event) -> bool:
  ...


rule = Rule(rule_checker1, rule_checker2)
```

这样的一个`Rule`即可作为一个事件响应器中参数`rule`的传入值

当然，多个`Rule`也可以合并为一个新`Rule`，中间使用`&`来进行连接，如

```python
Rule(...) & Rule(...)
```

##### RuleChecker

通过阅读`nonebot.rule`这个包，不难发现nonebot已经为我们内置了几个常用的`Rule``，内置的`Rule`列表自行查看源代码。

强烈不建议使用`to_me()`这种具有不明意义不明白具体判断逻辑的内置`RuleChecker`

#### permissions

基本同上面的`rule`，也拥有`Permission`与`PermissionChecker`两个概念

但是它与`rule`的最大区别在于`Permission`只需其中一个`PermissionChecker`返回`True`时就会检查通过

以及它在`nonebot`以及`onebot`等适配器中拥有预定义的几个`Permission`

因为它的判断用的是`or`，所以适合采用白名单的方式去判断哪些事件会被通过。如果有黑名单的情况下，最好在`Rule`中去定义黑名单的判断。

它和`Rule`的另一个区别是，`Rule`仅在初次触发事件响应器时进行检查，在余下的会话中并不会限制事件；而`Permission`会持续生效，在连续对话中一直对事件主体加以限制。

#### priority

是一个`int`值，该值越小优先级越高，一般的插件优先级请设置为`100`

#### block

这是一个`bool`值，用于定义是否在当前优先级阻断事件传播

当该值为`True`时，事件将会在当前优先级停止，不会继续向下一优先级传播，但同一优先级的其余插件仍会进行处理

当该值为`False`时候，不会阻止事件继续传播

### 事件响应器的属性与方法

自行打开源代码查看
